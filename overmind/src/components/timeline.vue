<template>
    <div>
        <div>
        CURR TARG
        </div>
        <div class="timeline" style="display: flex; flex-direction: column; position: relative">
            <div v-for="worker in workers" :key="worker.name" class="timeline-worker">
                <span class="timeline-header">{{worker.name}}</span>
                <span>
                    <div class="timeline-action" v-for="task in worker.tasks"
                         style="position:absolute; "
                         :style="{left: (pxPerSec * task.init + 100) + 'px', width: (pxPerSec * task.dur) + 'px'}">{{task.name}}</div>
                </span>
            </div>
        </div>
        <button class="btn btn-primary" @click="simStart">Sim Start</button>
        <button class="btn btn-primary" @click="simStop">Sim Stop</button>
        <span>T={{timeSec.toFixed(2)}}s</span>
        <div v-if="viewmodel.errorMsg" class="alert alert-warning">{{viewmodel.errorMsg}}</div>
        <button class="btn btn-start" @click="exec">Exec</button>
    </div>
</template>

<script>
import Vue from 'vue';

export default {
    props: ['viewmodel'],
    components: {
    },
    data() {
        const scale = 20.0;
        return {
            simInterval: null,
            timeOrigin: new Date(),
            timeNow: new Date(),
            pxPerSec: 100,
        };
    },
    computed: {
        workers() {
            const pl = this.viewmodel.plan;
            if (!pl) {
                return [];
            }

            const m = pl.getSeqPerWorker();
            let results = [];
            m.forEach((seqs, addr) => {
                const workerName = addr;
                results.push({
                    name: workerName,
                    tasks: seqs.map(tAndSq => {
                        return {
                            name: tAndSq.getLabel(),
                            init: tAndSq.getT0(),
                            dur: tAndSq.getDurationSec()
                        };
                    }),
                });
            });
            return results;
        },
        timeSec() {
            return (this.timeNow - this.timeOrigin) * 1e-3;
        }
    },
    methods: {
        simStart() {
            if (this.simInterval) {
                clearInterval(this.simInterval);
            }
            this.timeOrigin = new Date();
            this.simInterval = setInterval(() => {
                this.timeNow = new Date();
                this.viewmodel.setTime(this.timeSec);
            }, 50);
        },
        simStop() {
            if (this.simInterval) {
                clearInterval(this.simInterval);
                this.simInterval = null;
            }
        },
        exec() {
        }
    }
}
</script>

<style>
.timeline-worker {
    height: 35px;
    border-top: 1px solid white;
    padding-top: 5px;
    padding-bottom: 5px;
}

.timeline-header {
    padding-right: 2em;
}

.timeline-action {
    border: 1px solid #8ca;
    background-color: #888;
}
</style>