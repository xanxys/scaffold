#pragma once

#include <I2C.h>

/**
 * Driver for MLX90393 magnetic sensor, which is coupled to measure main axis
 * gear rotation. ds:
 * https://cdn.sparkfun.com/assets/learn_tutorials/5/7/7/MLX90393-Datasheet-Melexis.PDF
 *
 * sample code:
 * https://github.com/ControlEverythingCommunity/MLX90393/blob/master/Arduino/MLX90393.ino
 */
class Odometry {
 private:
  constexpr static uint8_t addr =
      20;  // designed to be 0x0c, but somehow ended up being 20.

  // Commands
  constexpr static uint8_t WRITE_REGISTER = 0x60;

  constexpr static uint8_t STATUS_BURST_MODE = _BV(7);
  constexpr static uint8_t STATUS_ERROR = _BV(4);

  struct __attribute__((__packed__)) U16Be {
    uint8_t h;
    uint8_t l;
  };

  struct __attribute__((__packed__)) ReadMeasurementResult {
    uint8_t status;
    U16Be x, y, z;
  };

  /**
   * These constants are generated by following python code:
   *
   * COS: python -c "import math; print [int(math.cos(i/128.0*math.pi)*255) for
   * i in range(64)]" SIN: python -c "import math; print
   * [int(math.sin(i/128.0*math.pi)*255) for i in range(64)]"
   */
  static constexpr uint8_t QUAD_ANGLE = 64;
  const uint8_t QUAD_COS[QUAD_ANGLE] = {
      255, 254, 254, 254, 253, 253, 252, 251, 250, 248, 247, 245, 244,
      242, 240, 237, 235, 233, 230, 227, 224, 221, 218, 215, 212, 208,
      204, 201, 197, 193, 188, 184, 180, 175, 171, 166, 161, 156, 151,
      146, 141, 136, 131, 125, 120, 114, 109, 103, 97,  91,  85,  79,
      74,  68,  61,  55,  49,  43,  37,  31,  24,  18,  12,  6};

  const uint8_t QUAD_SIN[QUAD_ANGLE] = {
      0,   6,   12,  18,  24,  31,  37,  43,  49,  55,  61,  68,  74,
      79,  85,  91,  97,  103, 109, 114, 120, 125, 131, 136, 141, 146,
      151, 156, 161, 166, 171, 175, 180, 184, 188, 193, 197, 201, 204,
      208, 212, 215, 218, 221, 224, 227, 230, 233, 235, 237, 240, 242,
      244, 245, 247, 248, 250, 251, 252, 253, 253, 254, 254, 254};

 public:
  bool init_success = false;
  int16_t vx = 0;
  int16_t vy = 0;

  uint8_t angle = 0;
  int8_t num_rot = 0;

  void init() {
    // Reset command.
    // I2c.write(addr, (uint8_t)0xf0);
    // delay(10);

    // Set RES{x,y,z} = 2, OSR=0, DIG_FILT=0
    write_reg(2, 0b101010 << 5);

    // COMM_MODE=I2C (0b11), BURST_DATE_RATE=1
    write_reg(1, (0b11 << 13) | 1);

    // GAIN=5, HALL_PLATE=0xc (default)
    write_reg(0, 0x5c);

    // Enter "Burst Mode", with measurement in all magnetic channels (Z, Y, X).
    //  I2c.write(addr, (uint8_t)0x1e);
    init_success = true;
    return;

    uint8_t status;
    uint8_t code = I2c.read(addr, 0x1e, (uint8_t)1, &status);
    vx = status + 1000;

    if ((status & STATUS_BURST_MODE) && !(status & STATUS_ERROR)) {
      init_success = true;
    }
  }

  void poll() {
    if (!init_success) {
      return;
    }
    uint8_t status;
    uint8_t code = I2c.read(addr, 0x3e, (uint8_t)1, &status);
    if (code != 0) {
      vx = 1000 + code;
      return;
    }
    if (status & STATUS_ERROR) {
      vx = 2000 + status;
      return;
    }
    delay(100);

    // Read measurement command
    I2c.write(addr, (uint8_t)0x4e);

    ReadMeasurementResult result;
    code = I2c.read(addr, 7, reinterpret_cast<uint8_t*>(&result));
    if (code != 0) {
      vx = 3000 + code;
      return;
    }
    if (result.status & STATUS_ERROR) {
      vx = 4000 + result.status;
      return;
    }
    // Expecting 6B data. -> must be 2 (2x2 + 2 = 6)
    if (result.status & 3 != 2) {
      vx = 5001;
      return;
    }
    vx = decode_value(result.x);
    vy = decode_value(result.y);
    const uint8_t new_angle = atan2(vx >> 8, vy >> 8);
    if (new_angle < 128) {
      if (angle >= 128) {
        num_rot++;
      }
    } else {
      if (angle < 128) {
        num_rot--;
      }
    }
    angle = new_angle;
  }

  int16_t get_rot() const { return num_rot * 256 + angle; }

 private:
  void write_reg(uint8_t mem_addr, uint16_t val) {
    uint8_t command[3];
    command[0] = val >> 8;
    command[1] = val & 0xff;
    command[2] = mem_addr << 2;
    I2c.write(addr, WRITE_REGISTER, command, (uint8_t)sizeof(command));

    uint8_t status;
    I2c.read(addr, 1, &status);
  }

  int16_t decode_value(const U16Be& v) {
    uint16_t temp = (((uint16_t)v.h) << 8) + v.l;
    if (temp > 0x8000) {
      return temp - 0x8000;
    } else {
      return -(0x8000 - temp);
    }
  }

  // Returns angle of vector (x, y), in [0, 256).
  // angle will be down-rounded.
  uint8_t atan2(int8_t x, int8_t y) const {
    if (y >= 0) {
      return x >= 0 ? atan2_quad(x, y) : atan2_quad(y, -x) + QUAD_ANGLE;
    } else {
      return x >= 0 ? (atan2_quad(-y, x) + QUAD_ANGLE * 3)
                    : (atan2_quad(-x, -y) + QUAD_ANGLE * 2);
    }
  }

  // Find angle of (x,y) using binary search.
  // precondition: x >= 0 & y >= 0
  uint8_t atan2_quad(uint8_t x, uint8_t y) const {
    uint8_t ix_b = 0;
    uint8_t ix_e = QUAD_ANGLE;

    while (ix_b + 1 < ix_e) {
      uint8_t ix_m = (ix_b + ix_e) >> 1;

      // sin(i)/cos(i) > y/x   <=>  sin(i)*x > cos(i)*y
      if (((uint16_t)QUAD_SIN[ix_m]) * x > ((uint16_t)QUAD_COS[ix_m]) * y) {
        // (x,y) has smaller angle than ix_m.
        ix_e = ix_m;
      } else {
        // (x,y) has equal or greater angle than ix_m.
        ix_b = ix_m;
      }
    }
    return ix_b;
  }
};
